基址加变址寻址
格式： [BR+IRxF+V]   
操作数的偏移=变址寄存器IR中的内容x比例因子F+位移量V+基址寄存器BR中的内容
EA=(IR)*F+V+(BR)

16位寄存器
BR是BX、BP之一，IR是SI、DI之一     F只能为1
当BR=BX，默认操作数在DS段中
BR=BP，默认在SS段

32位寄存器，BR都可以，IR是除ESP之外任一32位寄存器


例1： MOV AX,8[BX][SI]
执行前：   (AX)=45H,(BX)=30H,(SI)=20H
                 DS:(0058H)=99H
执行后：   (AX)=99H
                (BX),(SI),DS:(0058H)



立即寻址
格式：  n
例子：  MOV AX,10



直接寻址
格式：  段寄存器名：[N]   或   变量   或 变量+常量    （以字节为单位）
为什么可以用变量，因为变量知道在哪个段里面，直接用就行


区分：
ADD  AH，BUF
INC   BUF
这里BUF并不会往后偏移，因为INC BUF  是BUF里的内容+1，假设原本BUF变量存的是10，那么执行之后BUF变量存的就是11
要 MOV BX，OFFSET BUF         ;这里把BUF的地址给了BX
然后   ADD AH，[BX]
          INC BX
这样才会累加连续字节内存里的值，这时候BX代表的才是地址，BX++才是后移
可以理解为，INC操作的是值，上面BUF里面的值就是值，而BX里面的值是地址



双操作数里面，至少有一个类型是明确的。若两个类型都明确，两个类型应该相同
MOV  BX,AX
MOV BX,AL     错，两个操作数类型不匹配
MOV [BX],0    错，两个操作数类型都不明确

段选择说明：
1、标明了段寄存器，则在标明的段中。   比如SS:[BX]，说明是在堆栈段
2、若有变量，则是变量所在段，否则3
3、系统默认（V为常量时）
  对于[R]，R为BP、EBP、ESP，在SS段
      V[R*F]，R……
     V[BR+IR*F]  BR为……


跨段前缀：
作用以及作用域：过了这个村就没有这个店
MOV AX，      [BP]       
MOV BX，DS:[BP]
MOV CX，      [BP]
如上代码，只有中间那一条指令，BP表示的是数据段，其余两条是堆栈段
